<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 平衡二叉树(avl) · RainZhao</title><meta name="description" content="平衡二叉树(avl) - 赵宇"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.png"><link rel="stylesheet" href="/css/apollo.css"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="RainZhao"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/rainzhao" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/rainzhao" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><aside id="article-toc" role="navigation" class="fixed"><div id="article-toc-inner"><strong class="sidebar-title">目录
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高度和平衡因子"><span class="toc-number">2.</span> <span class="toc-text">高度和平衡因子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现一个AVLTree"><span class="toc-number">3.</span> <span class="toc-text">实现一个AVLTree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#左旋转与右旋转"><span class="toc-number">4.</span> <span class="toc-text">左旋转与右旋转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树的遍历"><span class="toc-number">5.</span> <span class="toc-text">树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#层序遍历"><span class="toc-number">5.1.</span> <span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优先遍历"><span class="toc-number">5.2.</span> <span class="toc-text">深度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试"><span class="toc-number">6.</span> <span class="toc-text">测试</span></a></li></ol></strong></div></aside><div class="lookeye"><span id="busuanzi_container_page_pv"></span>Viewd<span id="busuanzi_value_page_pv"> </span>times<img src="/eye.png"></div><article class="post-block"><h1 class="post-title">平衡二叉树(avl)</h1><div class="post-info">Jul 5, 2019</div><div class="post-content"><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<h2 id="高度和平衡因子"><a href="#高度和平衡因子" class="headerlink" title="高度和平衡因子"></a>高度和平衡因子</h2><p>如下就是一棵AVL树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       12</span><br><span class="line">     /    \</span><br><span class="line">    8     18</span><br><span class="line">   / \    /</span><br><span class="line">  5  11  17</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<ol>
<li>高度： 规定叶子节点的高度为1。 非叶子节点，取左右子树中<strong>高度最高</strong>的节点高度值并<strong>加一</strong>(+1其实加的是自身的高度)</li>
<li>平衡因子：左右子树的高度差。</li>
</ol>
<p>高度计算举例： </p>
<ul>
<li>如5这个节点的高度为: 4节点的高度+1,4是叶子节点则4节点的高度为1，而+1其实是5自身的高度即5节点高度为： <code>1+1 = 2</code>， 所以5这个节点的高度为2。<br>再如8这个节点的高度为:左右子树高度最高的值+1，8的左节点高度为2，右节点高度为1，左右节点高度最高为2 即5节点的高度为：<code>2 + 1 = 3</code><br>平衡因子计算举例：</li>
<li>4节点的平衡因子为0，因为该节点没有左右子树。<br>5节点的平衡因子为1，左右子树高度值相减取绝对值。</li>
</ul>
<h2 id="实现一个AVLTree"><a href="#实现一个AVLTree" class="headerlink" title="实现一个AVLTree"></a>实现一个AVLTree</h2><p>成员变量如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">        <span class="comment">// 节点高度</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            height = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算节点高度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上定义了一个Node类，主要有树的节点的key，value， 以及左右子树，还有此节点的高度。</p>
<p>接下来向节点中添加元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 向以node为根的二分搜索树中插入元素(key, value) ，递归</span></span><br><span class="line"><span class="comment">  * 返回插入新节点后二分搜索树的根</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">          size++;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 当要添加的节点的值小于当前节点时向左子树中添加节点</span></span><br><span class="line">          node.left = add(node.left, key, value);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 当要添加的节点的值大于当前节点时向右子树中添加节点</span></span><br><span class="line">          node.right = add(node.right, key, value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 当值相等时，替换原有值</span></span><br><span class="line">          node.value = value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新height</span></span><br><span class="line">      node.height = <span class="number">1</span> + Math.max(getHeight(node.left), getHeight(node.right));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 计算平衡因子</span></span><br><span class="line">      <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">      <span class="comment">// 当该节点的平衡因子大于1时 &amp;&amp; 该节点的左子树的平衡因子大于1时 此时需要做右旋转来保证左右子树的高度差不超过1</span></span><br><span class="line">      <span class="keyword">if</span> (Math.abs(balanceFactor) &gt; <span class="number">1</span> &amp;&amp; Math.abs(getBalanceFactor(node.left)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否需要右旋转，当该节点的平衡因子大于1时 &amp;&amp; 该节点的右子树的平衡因子大于1时，此时需要左旋转来保证左右子树的高度差不超过1</span></span><br><span class="line">      <span class="keyword">if</span> (Math.abs(balanceFactor) &gt; <span class="number">1</span> &amp;&amp; Math.abs(getBalanceFactor(node.right)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="左旋转与右旋转"><a href="#左旋转与右旋转" class="headerlink" title="左旋转与右旋转"></a>左旋转与右旋转</h2><p>左旋转和右旋转都需要满足一个条件：当左右子树高度差超过1时，即此节点的平衡因子大于1。</p>
<p>如下此棵树，当添加T1 或T2节点时就会满足旋转的条件。这里T1和T2同时存在是为了看起来整棵树对称些，其实当Z节点添加任意一个子节点时，就满足了需要旋转的条件了。</p>
<p>当Z添加任意子节点后，会计算层层往上计算节点的高度值：</p>
<ul>
<li>Z节点插入T节点后高度值变为2，X节点高度值变为3，Y节点高度变为4，Y节点的平衡因子为：X高度-T4高度 = 2<br>此时已不满足一棵平衡二叉树的定义，故需要进行旋转操作。</li>
<li>当满足旋转条件后还需要判断要做哪种旋转，如果是y的右子树的节点的平衡因子大于0，证明其是右子树高度过高导致的不平衡，故需要进行左旋转，如果是y的左子树的节点的平衡因子大于0，证明其是左子树的高度过高导致的不平衡，故需要做右旋转，下面这棵树是右子树的节点X的平衡因子大于0 故需要做左旋转。</li>
</ul>
<p>左旋转的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      y                              X</span><br><span class="line">    /   \                          /   \</span><br><span class="line">   T4    X         左旋转          y     Z</span><br><span class="line">        / \      =========&gt;      / \   /  \</span><br><span class="line">       T3  Z                    T4 T3 T1  T2</span><br><span class="line">          / \</span><br><span class="line">         T1  T2</span><br><span class="line">过程：</span><br><span class="line"><span class="number">1</span>. Node X = y.right;</span><br><span class="line"><span class="number">2</span>. Node T3 = X.left;</span><br><span class="line"><span class="number">3</span>. X.left = y;</span><br><span class="line"><span class="number">4</span>. y.right = T3;</span><br><span class="line"></span><br><span class="line">旋转后为何还能保证是一棵二叉搜索树？</span><br><span class="line">旋转前：  T4 &lt; Y &lt; T3 &lt; X &lt; T1 &lt; Z &lt; T2</span><br><span class="line">旋转后：  T4 &lt; Y &lt; T3 &lt; X &lt; T1 &lt; Z &lt; T2  节点之间的大小关系不会变化，保证了其还是一个二叉搜索树</span><br><span class="line"></span><br><span class="line">旋转后为何可以保证其是一个平衡二叉树（AVL树）？</span><br><span class="line">旋转前后 T1，T2, T3, T4 都是叶子节点，前后高度值未变化，都是<span class="number">1</span>, 只有X和Y节点的高度变化了，</span><br><span class="line">而每次旋转的过程都是在添加元素后，递归的一层一层往上查找的不满足平衡的节点，</span><br><span class="line">保证了添加元素后最近的那个不满足平衡的节点并进行旋转处理。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    Node x = y.right;</span><br><span class="line">    Node T3 = x.left;</span><br><span class="line">    x.left = y;</span><br><span class="line">    y.right = T3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算X和Y的节点高度</span></span><br><span class="line">    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>右旋转的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         y                       x              过程：</span><br><span class="line">        / \                    /   \             <span class="number">1</span>. Node x = y.left;</span><br><span class="line">       x   T4    右旋转        z     y            <span class="number">2</span>. Node T3 = x.right;</span><br><span class="line">      / \      =========&gt;    / \   /  \          <span class="number">3</span>. x.right = y;</span><br><span class="line">     z   T3                 T1 T2 T3  T4         <span class="number">4</span>. y.left = T3;</span><br><span class="line">    / \</span><br><span class="line">   T1  T2</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    Node x = y.left;</span><br><span class="line">    Node t3 = x.right;</span><br><span class="line">    x.right = y;</span><br><span class="line">    y.left = t3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算高度(先计算y节点的高度因为x节点的高度依赖于y)</span></span><br><span class="line">    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的遍历有两种方式：</p>
<ol>
<li>广度优先遍历 ：也叫层序遍历，一层一层的访问每个节点。</li>
<li>深度优先遍历（前序遍历，中序遍历，后续遍历），访问根节点的顺序决定了其是什么遍历方式。</li>
</ol>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历也叫广度优先遍历，一般借助于队列去实现。</p>
<p>树结构如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">            <span class="number">18</span></span><br><span class="line">          /    \</span><br><span class="line">        <span class="number">16</span>      <span class="number">30</span></span><br><span class="line">       /  \    /   \</span><br><span class="line">      <span class="number">15</span>  <span class="number">17</span>  <span class="number">20</span>    <span class="number">34</span></span><br><span class="line">             /  \   / \</span><br><span class="line">            <span class="number">19</span>  <span class="number">28</span> <span class="number">32</span>  <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. [<span class="number">18</span>] 入队后出队，并将<span class="number">18</span>的左右节点<span class="number">16</span>，<span class="number">30</span>节点添加到队列中：| <span class="number">16</span> | <span class="number">30</span> |。</span><br><span class="line"><span class="number">2</span>. <span class="number">16</span> 出队，将<span class="number">16</span>的左右子树节点<span class="number">15</span>，<span class="number">17</span>依次入队，| <span class="number">30</span> | <span class="number">15</span> | <span class="number">17</span> |。</span><br><span class="line"><span class="number">3</span>. <span class="number">30</span> 出队，将<span class="number">30</span>的左右子树节点<span class="number">20</span>，<span class="number">34</span>依次入队：| <span class="number">15</span> | <span class="number">17</span> | <span class="number">20</span> | <span class="number">34</span> | 此时队列中就是第三层的树了。 </span><br><span class="line"><span class="number">4</span>. 依此类推，遍历完整棵树，最后的结果为：[<span class="number">18</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">19</span>, <span class="number">28</span>, <span class="number">32</span>, <span class="number">36</span>]</span><br><span class="line"></span><br><span class="line">code :</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列进行层序遍历</span></span><br><span class="line">    Queue&lt;Node&gt; list = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// push根节点</span></span><br><span class="line">    list.add(node);</span><br><span class="line">    <span class="comment">// 存放结果的list</span></span><br><span class="line">    List&lt;K&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 进行广度优先遍历</span></span><br><span class="line">    printNodeLoop(list, resultList);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    System.out.println(resultList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 广度优先遍历(层序遍历)</span></span><br><span class="line"><span class="comment">* 使用队列实现</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printNodeLoop</span><span class="params">(Queue&lt;Node&gt; list, List&lt;K&gt; resultList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node pop = list.remove();</span><br><span class="line">        resultList.add(pop.key);</span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(pop.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(pop.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>这里使用递归的方式，进行中序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            <span class="number">18</span></span><br><span class="line">          /    \</span><br><span class="line">        <span class="number">16</span>      <span class="number">30</span></span><br><span class="line">       /  \    /   \</span><br><span class="line">      <span class="number">15</span>  <span class="number">17</span>  <span class="number">20</span>    <span class="number">34</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root, List&lt;K&gt; keys)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrder(root.left, keys);</span><br><span class="line">    keys.add(root.key);</span><br><span class="line">    inOrder(root.right, keys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的遍历上述整棵树的过程：<br>每一次的递归调用，都会有系统栈去暂存此时的变量。</p>
<ol>
<li>先去递归的遍历左子树，直至此节点的左子树为null时，添加此节点的值。</li>
<li>再去递归遍历此节点的右子树，直至此节点的右子树为null时，返回到上一此的系统栈。</li>
<li>到上一层的系统栈时，添加此节点的值，因为此时该节点左子树已填加故需要添加根节点了，再去递归遍历右子树的值…。</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试用例：</span></span><br><span class="line"><span class="comment">* // 根节点</span></span><br><span class="line"><span class="comment">* avlTree.add(20, "Y");</span></span><br><span class="line"><span class="comment">* // 左子树</span></span><br><span class="line"><span class="comment">* avlTree.add(18, "X");</span></span><br><span class="line"><span class="comment">* avlTree.add(30, "X4");</span></span><br><span class="line"><span class="comment">* avlTree.add(16, "Z");</span></span><br><span class="line"><span class="comment">* avlTree.add(19, "X3");</span></span><br><span class="line"><span class="comment">* avlTree.add(15, "X1");</span></span><br><span class="line"><span class="comment">* avlTree.add(17, "X2");</span></span><br><span class="line"><span class="comment">* // 右子树</span></span><br><span class="line"><span class="comment">* avlTree.add(30, "B");</span></span><br><span class="line"><span class="comment">* avlTree.add(28, "Q3");</span></span><br><span class="line"><span class="comment">* avlTree.add(34, "A");</span></span><br><span class="line"><span class="comment">* avlTree.add(32, "Q1");</span></span><br><span class="line"><span class="comment">* avlTree.add(36, "Q3");</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 第一次右旋转（添加15节点）后：</span></span><br><span class="line"><span class="comment">*       18</span></span><br><span class="line"><span class="comment">*      /  \</span></span><br><span class="line"><span class="comment">*     16  20</span></span><br><span class="line"><span class="comment">*    /    / \</span></span><br><span class="line"><span class="comment">*   15   19  30</span></span><br><span class="line"><span class="comment">* 添加32节点前：</span></span><br><span class="line"><span class="comment">*          18</span></span><br><span class="line"><span class="comment">*        /    \</span></span><br><span class="line"><span class="comment">*       16     20</span></span><br><span class="line"><span class="comment">*      /  \   /  \</span></span><br><span class="line"><span class="comment">*     15  17 19  30</span></span><br><span class="line"><span class="comment">*               /  \</span></span><br><span class="line"><span class="comment">*              28  34</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 第一次左旋转（添加32节点）后：</span></span><br><span class="line"><span class="comment">*            18</span></span><br><span class="line"><span class="comment">*          /    \</span></span><br><span class="line"><span class="comment">*        16      30</span></span><br><span class="line"><span class="comment">*       /  \    /   \</span></span><br><span class="line"><span class="comment">*      15  17  20    34</span></span><br><span class="line"><span class="comment">*             /  \   / </span></span><br><span class="line"><span class="comment">*            19  28 32</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AVLTree&lt;Integer, String&gt; avlTree = <span class="keyword">new</span> AVLTree&lt;&gt;();</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    avlTree.add(<span class="number">20</span>, <span class="string">"Y"</span>);</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    avlTree.add(<span class="number">18</span>, <span class="string">"X"</span>);</span><br><span class="line">    avlTree.add(<span class="number">30</span>, <span class="string">"X4"</span>);</span><br><span class="line">    avlTree.add(<span class="number">16</span>, <span class="string">"Z"</span>);</span><br><span class="line">    avlTree.add(<span class="number">19</span>, <span class="string">"X3"</span>);</span><br><span class="line">    avlTree.add(<span class="number">15</span>, <span class="string">"X1"</span>);</span><br><span class="line">    avlTree.add(<span class="number">17</span>, <span class="string">"X2"</span>);</span><br><span class="line">    <span class="comment">// 右子树</span></span><br><span class="line">    avlTree.add(<span class="number">28</span>, <span class="string">"Q3"</span>);</span><br><span class="line">    avlTree.add(<span class="number">34</span>, <span class="string">"A"</span>);</span><br><span class="line">    avlTree.add(<span class="number">32</span>, <span class="string">"Q1"</span>);</span><br><span class="line">    avlTree.add(<span class="number">36</span>, <span class="string">"Q3"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    avlTree.inOrder(avlTree.root, keys);</span><br><span class="line">    System.out.println(<span class="string">"中序遍历："</span> + keys);</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">"层序遍历："</span>);</span><br><span class="line">    avlTree.printNode(avlTree.root);</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"是否是一棵平衡二叉树："</span> +avlTree.isBalanced());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最终的树的结构如下：</span><br><span class="line">            <span class="number">18</span></span><br><span class="line">          /    \</span><br><span class="line">        <span class="number">16</span>      <span class="number">30</span></span><br><span class="line">       /  \    /   \</span><br><span class="line">      <span class="number">15</span>  <span class="number">17</span>  <span class="number">20</span>    <span class="number">34</span></span><br><span class="line">             /  \   / \</span><br><span class="line">            <span class="number">19</span>  <span class="number">28</span> <span class="number">32</span>  <span class="number">36</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p>中序遍历：[15, 16, 17, 18, 19, 20, 28, 30, 32, 34, 36]<br>层序遍历：[18, 16, 30, 15, 17, 20, 34, 19, 28, 32, 36]</p>
<p>是否是一棵平衡二叉树：true</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/03/11/lambda应用到builder模式/" class="prev">PREV</a><a href="/2019/03/21/udp的单播和广播（组播）/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/07/05/平衡二叉树-avl/';
var disqus_title = '平衡二叉树(avl)';
var disqus_url = 'http://yoursite.com/2019/07/05/平衡二叉树-avl/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">赵宇</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>